<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>笔记</title>
    <url>/2021/12/30/C-Primer%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="文本查询程序"><a href="#文本查询程序" class="headerlink" title="文本查询程序"></a>文本查询程序</h3><p>用智能指针实现类间数据传递</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> line_no=vector&lt;string&gt;::size_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在类TextQuery内寻找，将搜索结果传入类QueryResult*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>;</span></span><br><span class="line"><span class="comment">//此函数控制输出单词单复数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> ctr,<span class="keyword">const</span> string &amp;word,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> string &amp;endi)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;,<span class="keyword">const</span> QueryResult&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类存储数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TextQuery</span>(ifstream&amp;);</span><br><span class="line">    <span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> string&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; file;</span><br><span class="line">    map&lt;string,shared_ptr&lt;set&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储结果的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;,<span class="keyword">const</span> QueryResult&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">QueryResult</span>(string s,shared_ptr&lt;set&lt;line_no&gt;&gt; p,</span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; f);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string search;</span><br><span class="line">    shared_ptr&lt;set&lt;line_no&gt;&gt; lines;</span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; file;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QueryResult::<span class="built_in">QueryResult</span>(string s,shared_ptr&lt;set&lt;line_no&gt;&gt; p,</span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; f) : <span class="built_in">search</span>(s), <span class="built_in">lines</span>(p), <span class="built_in">file</span>(f)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">TextQuery::<span class="built_in">TextQuery</span>(ifstream &amp;ifs) : <span class="built_in">file</span>(<span class="keyword">new</span> vector&lt;string&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    string text;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(ifs,text))</span><br><span class="line">    &#123;</span><br><span class="line">        file-&gt;<span class="built_in">push_back</span>(text);</span><br><span class="line">        <span class="keyword">int</span> n=file-&gt;<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">istringstream <span class="title">line</span><span class="params">(text)</span></span>;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span>(line&gt;&gt;word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;lines=wm[word];</span><br><span class="line">            <span class="keyword">if</span>(!lines)</span><br><span class="line">                lines.<span class="built_in">reset</span>(<span class="keyword">new</span> set&lt;line_no&gt;);</span><br><span class="line">            lines-&gt;<span class="built_in">insert</span>(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QueryResult <span class="title">TextQuery::query</span><span class="params">(<span class="keyword">const</span> string &amp;search)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> shared_ptr&lt;set&lt;line_no&gt;&gt; <span class="built_in">nodata</span>(<span class="keyword">new</span> set&lt;line_no&gt;);</span><br><span class="line">    <span class="keyword">auto</span> loc=wm.<span class="built_in">find</span>(search);</span><br><span class="line">    <span class="keyword">if</span>(loc==wm.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QueryResult</span>(search,nodata,file);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QueryResult</span>(search,loc-&gt;second,file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> ctr,<span class="keyword">const</span> string &amp;word,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> string &amp;endi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ctr&gt;<span class="number">1</span>) ? word+endi : word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;cout,<span class="keyword">const</span> QueryResult &amp;qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;qr.search&lt;&lt;<span class="string">&quot; occurs &quot;</span>&lt;&lt;qr.lines-&gt;<span class="built_in">size</span>()</span><br><span class="line">    &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">make_plural</span>(qr.lines-&gt;<span class="built_in">size</span>(),<span class="string">&quot;time&quot;</span>,<span class="string">&quot;s&quot;</span>)</span><br><span class="line">    &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num: *(qr.lines))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\t(line &quot;</span>&lt;&lt;num+<span class="number">1</span>&lt;&lt;<span class="string">&quot;) &quot;</span>&lt;&lt;</span><br><span class="line">        *(qr.file-&gt;<span class="built_in">begin</span>()+num)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;ifs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">TextQuery <span class="title">tq</span><span class="params">(ifs)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;enter word to look for, or q to quit\n&quot;</span>);</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">if</span>(!(cin&gt;&gt;tmp)||tmp==<span class="string">&quot;q&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">print</span>(cout,tq.<span class="built_in">query</span>(tmp))&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;C:\\test\\tst.txt&quot;</span>,ios::in);</span><br><span class="line">    <span class="built_in">runQueries</span>(ifs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用类型"><a href="#调用类型" class="headerlink" title="调用类型"></a>调用类型</h3><h5 id="不同类型可以具有相同的调用形式"><a href="#不同类型可以具有相同的调用形式" class="headerlink" title="不同类型可以具有相同的调用形式"></a>不同类型可以具有相同的调用形式</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="comment">//lambda</span></span><br><span class="line"><span class="keyword">auto</span> mod=[](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;<span class="keyword">return</span> x%y;&#125;;</span><br><span class="line"><span class="comment">//函数对象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">divide</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x/y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//共享调用形式int(int, int)</span></span><br></pre></td></tr></table></figure>

<h5 id="function类型"><a href="#function类型" class="headerlink" title="function类型"></a>function类型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用map创建函数表</span></span><br><span class="line">map&lt;string,(<span class="keyword">int</span>*)(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; functable; <span class="comment">//可以存储add</span></span><br><span class="line">functable.<span class="built_in">insert</span>(pair&lt;string,<span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&#123;<span class="string">&quot;+&quot;</span>,add&#125;);</span><br><span class="line"><span class="comment">/*但不能存储mod与divide，</span></span><br><span class="line"><span class="comment">可以使用标准库function解决*/</span></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; <span class="comment">//表示接受两个int，返回一个int的可调用对象</span></span><br></pre></td></tr></table></figure>

<h5 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">divide</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;NaN\n&quot;</span>);<span class="built_in">exit</span>(EXIT_SUCCESS);&#125;</span><br><span class="line">        <span class="keyword">return</span> x/y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> mod=[](<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!y) &#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">        <span class="keyword">return</span> x%y;</span><br><span class="line">    &#125;;</span><br><span class="line">    map&lt;string,function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; functable=</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;+&quot;</span>, add&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;-&quot;</span>, minus&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;*&quot;</span>, [](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;<span class="keyword">return</span> x*y;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;/&quot;</span>, <span class="built_in">divide</span>()&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;%&quot;</span>, mod&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入\n格式: 操作数 运算符 操作数2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    string operate;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;operate&gt;&gt;y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,functable[operate](x, y));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复制对象每一部分"><a href="#复制对象每一部分" class="headerlink" title="复制对象每一部分"></a>复制对象每一部分</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logCall</span> <span class="params">(<span class="keyword">const</span> string&amp; funcname)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Customer</span>(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>==(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Customer::<span class="built_in">Customer</span>(<span class="keyword">const</span> Customer&amp; rhs) : <span class="built_in">name</span>(rhs.name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;customer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>==(<span class="keyword">const</span> Customer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;CUstomer copy assignment operator&quot;</span>);</span><br><span class="line">    name = rhs.name;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------Customer-----------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pro</span> :</span> <span class="keyword">public</span> Customer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">pro</span>();</span><br><span class="line">    <span class="built_in">pro</span>(<span class="keyword">const</span> pro&amp; rhs);</span><br><span class="line">    pro&amp; <span class="keyword">operator</span>==(<span class="keyword">const</span> pro&amp; rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pro类内函数</span></span><br><span class="line">pro::<span class="built_in">pro</span>(<span class="keyword">const</span> pro&amp; rhs) : <span class="built_in">priority</span>(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Pro copy constructor&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">pro&amp; pro::<span class="keyword">operator</span>==(<span class="keyword">const</span> pro&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Pro copy assignment operator&quot;</span>);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这时，pro中priority被拷贝，但pro类中继承自Customer的部分未被拷贝。编写拷贝构造函数</span></span><br><span class="line"><span class="comment">必须注意到其base class的部分*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确做法</span></span><br><span class="line">pro::<span class="built_in">pro</span>(<span class="keyword">const</span> pro&amp; rhs) : <span class="built_in">priority</span>(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Pro copy constructor&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">pro&amp; pro::<span class="keyword">operator</span>==(<span class="keyword">const</span> pro&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Pro copy assignment operator&quot;</span>);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    Customer::<span class="keyword">operator</span>==(rhs); </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*还需注意，若为class添加成员，必须修改所有构造函数*/</span></span><br></pre></td></tr></table></figure>

<h3 id="编写new与内存不足处理例程"><a href="#编写new与内存不足处理例程" class="headerlink" title="编写new与内存不足处理例程"></a>编写new与内存不足处理例程</h3><p>伪码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        size = <span class="number">1</span>;<span class="comment">//0 byte 视为 1byte</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        尝试分配 size bytes;</span><br><span class="line">        <span class="keyword">if</span>(成功)</span><br><span class="line">            <span class="keyword">return</span> 指针指向分配的内存;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//分配失败</span></span><br><span class="line">        <span class="comment">//获取当前new-handling函数</span></span><br><span class="line">        std::new_handler globhandler = std::<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(globhandler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == globhandler) <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        <span class="comment">//调用</span></span><br><span class="line">        (*globhandler)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，式<code>void (* set_malloc_handler(void (*f)())) ();</code></p>
<p>声明了一个名为set_malloc_handler的函数，它接受一个函数指针<code>void (*f)()</code>，这个函数指针指向参数列表空，返回空的函数，返回一个函数指针，指向参数列表空，返回空的函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2021/12/11/KMP/</url>
    <content><![CDATA[<p>在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!needle.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>* next=<span class="keyword">new</span> <span class="keyword">int</span>[needle.<span class="built_in">length</span>()];</span><br><span class="line">        <span class="built_in">Creatnext</span>(next,needle);</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;haystack.<span class="built_in">length</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(haystack[i]!=needle[j+<span class="number">1</span>]&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">                j=next[j];</span><br><span class="line">            <span class="keyword">if</span>(haystack[i]==needle[j+<span class="number">1</span>])</span><br><span class="line">                ++j;</span><br><span class="line">            <span class="keyword">if</span>(j==(<span class="keyword">int</span>)needle.<span class="built_in">length</span>()<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> []next;</span><br><span class="line">                <span class="keyword">return</span> i-needle.<span class="built_in">length</span>()+<span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> []next;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Creatnext</span><span class="params">(<span class="keyword">int</span>* next,<span class="keyword">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>]=j;</span><br><span class="line">        <span class="keyword">for</span>(string::size_type i=<span class="number">1</span>;i&lt;s.<span class="built_in">length</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;s[i]!=s[j+<span class="number">1</span>])</span><br><span class="line">                j=next[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>])</span><br><span class="line">                ++j;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github blog</title>
    <url>/2021/11/16/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h4><p>搭建博客需要以下软件</p>
<p>Git <a href="https://git-scm.com/">git</a>  <a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">安装教程</a></p>
<p>Node.js <a href="https://nodejs.org/en/">nodejs</a>  <a href="https://www.cnblogs.com/liuqiyun/p/8133904.html">安装教程</a></p>
<p>Notepad++ <a href="https://notepad-plus.en.softonic.com/">notepad++</a></p>
<p>压缩软件</p>
<p>下载链接、安装教程已附在后方，基本没有大问题。下面重点为hexo的安装和配</p>
<p>置。</p>
<h4 id="搭建github库"><a href="#搭建github库" class="headerlink" title="搭建github库"></a>搭建github库</h4><p>new新建仓库，注意仓库名为 github用户名.github.io</p>
<p>若github用户名为samual，则仓库名为 samual.github.io</p>
<p>勾选 Add a README file</p>
<h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>在任意文件夹下右键Git Bash Here, </p>
<p>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;github注册邮箱&quot;</span></span><br><span class="line"><span class="comment">#之后敲几次回车直到出现新的一行</span></span><br></pre></td></tr></table></figure>

<p>注意git命令行鼠标右键可进行复制粘贴</p>
<p>copy与paste</p>
<p>完成后进入C:\Users\用户名.ssh</p>
<p>注意自己电脑的用户名</p>
<p>打开.ssh文件，用notepad++编辑id_rsa.pub，完全复制其中的内容</p>
<p>打开github，在settings中找到SSH and GPG keys</p>
<p>新建SSH keys，title无所谓，将id_rsa.pub中的内容复制到key中</p>
<h4 id="在本地生成博客"><a href="#在本地生成博客" class="headerlink" title="在本地生成博客"></a>在本地生成博客</h4><p>在任意地方新建文件夹，在其中git bash;</p>
<p>输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br><span class="line">hexo init <span class="comment">#这一步初始化，从其他地方拷贝文件到该文件夹内</span></span><br><span class="line">hexo s <span class="comment">#启动服务，访问git中出现的网址</span></span><br></pre></td></tr></table></figure>

<p>CTRL C 关闭本地服务器，网页无法访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果npm命令执行缓慢，可以使用淘宝镜像</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"><span class="comment">#之后所有的npm改为cnpm</span></span><br></pre></td></tr></table></figure>

<h4 id="网上生成博客"><a href="#网上生成博客" class="headerlink" title="网上生成博客"></a>网上生成博客</h4><p>在文件夹中找到_config.yml，用vscode或notepa++打开，在最下方找到deploy；</p>
<p>改为以下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: ssh://git@github.com:github用户名/github用户名.github.io.git</span><br><span class="line">  <span class="comment">#注意修改</span></span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>然后使用git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装工具</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo g <span class="comment">#生成页面</span></span><br><span class="line">hexo d <span class="comment">#将本地内容上传到仓库</span></span><br></pre></td></tr></table></figure>

<h4 id="写、发布博客"><a href="#写、发布博客" class="headerlink" title="写、发布博客"></a>写、发布博客</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;博客名&quot;</span></span><br><span class="line"><span class="comment">#会在source\_posts文件夹下生成.md 文件</span></span><br><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line"><span class="comment">#写好后发布</span></span><br></pre></td></tr></table></figure>

<h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a><strong>主题配置</strong></h4><p>如果不喜欢现在的主题可以去next官网或者GitHub上自行搜索。<a href="http://theme-next.iissnan.com/">next官网</a></p>
]]></content>
  </entry>
  <entry>
    <title>矩阵求逆</title>
    <url>/2021/11/18/k/</url>
    <content><![CDATA[<h5 id="相关公式"><a href="#相关公式" class="headerlink" title="相关公式"></a>相关公式</h5><p><img src="/2021/11/18/k/k2.jpg"></p>
<p>需求得矩阵A的行列式det(A)，求出A的伴随矩阵，每个元素除以det(A)即求得逆矩阵</p>
<h5 id="求行列式"><a href="#求行列式" class="headerlink" title="求行列式"></a>求行列式</h5><p>代码中计算n阶行列式的方式：用深度优先搜索算法获取n个不同行不同列元素的乘积，</p>
<p>用一个函数确定奇偶排列，将它们相加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断奇偶排列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serh</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[i])</span><br><span class="line">                ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt%<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="comment">//k存放数的乘积，book数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row==n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">serh</span>(order))</span><br><span class="line">            temp=<span class="number">1</span>;</span><br><span class="line">        sum+=temp*k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(book[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            order[row]=i;<span class="comment">//更新顺序</span></span><br><span class="line">            book[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(row+<span class="number">1</span>,k*a[row][i]);</span><br><span class="line">            book[i]=<span class="number">0</span>;<span class="comment">//取消标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">101</span>],sum,n;</span><br><span class="line"><span class="comment">//行列式</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>][<span class="number">101</span>],order[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serh</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row==n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">serh</span>(order))</span><br><span class="line">            temp=<span class="number">1</span>;</span><br><span class="line">        sum+=temp*k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(book[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            order[row]=i;</span><br><span class="line">            book[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(row+<span class="number">1</span>,k*a[row][i]);</span><br><span class="line">            book[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断奇偶排列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serh</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[i])</span><br><span class="line">                ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt%<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="求逆"><a href="#求逆" class="headerlink" title="求逆"></a>求逆</h5><p>可将求伴随矩阵与求逆的过程合并</p>
<p>遍历矩阵A，求出每个元素的代数余子式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rac函数求行列式, 它的声明为</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rac</span><span class="params">(vector&lt;vector&lt;<span class="keyword">double</span>&gt; &gt; a)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">double</span>&gt; &gt; <span class="built_in">a</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">double</span>&gt;(n+<span class="number">1</span>));<span class="comment">//矩阵A</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">double</span>&gt; &gt; <span class="built_in">rev</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">double</span>&gt;(n+<span class="number">1</span>));<span class="comment">//存储逆矩阵</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">double</span>&gt; &gt; <span class="built_in">rc</span>(n,vector&lt;<span class="keyword">double</span>&gt;(n));<span class="comment">//A的子阵</span></span><br><span class="line">	<span class="keyword">double</span> xy;<span class="comment">//系数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//上两层循环遍历A, 求a[i][j]的余子式</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> te1=<span class="number">1</span>,te2=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;++k)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;=n;++m)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//下两层循环取得子阵</span></span><br><span class="line">                    <span class="keyword">if</span>(k!=i&amp;&amp;m!=j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        rc[te1][te2]=a[k][m];<span class="comment">//存储子阵</span></span><br><span class="line">                        te1++;</span><br><span class="line">                        <span class="keyword">if</span>(te1==n)</span><br><span class="line">                        &#123;</span><br><span class="line">                            te2++;</span><br><span class="line">                            te1=<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//求代数余子式</span></span><br><span class="line">            <span class="keyword">if</span>((j+i)%<span class="number">2</span>)	 xy=<span class="number">-1.0</span>;</span><br><span class="line">            <span class="keyword">else</span>  xy=<span class="number">1.0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注意伴随矩阵以转置的顺序存储</span></span><br><span class="line">            rev[j][i]=xy*<span class="built_in">rac</span>(rc)/deta;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>最后，如果打印rev，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>,rev[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可能会打出-0.00，如图</p>
<p><img src="/2021/11/18/k/k1.jpg"></p>
<p>这是由于浮点数精度导致，0是不在浮点数表示范围内的</p>
<p>把打印语句改为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rev[i][j]&lt;=<span class="number">0</span>&amp;&amp;(rev[i][j]+<span class="number">0.05</span>&gt;<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0.00 &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>,rev[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>即可解决问题</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>配置opencv-c++ opencv4</title>
    <url>/2021/11/17/vs2019%E9%85%8D%E7%BD%AEopencv-c-Windows/</url>
    <content><![CDATA[<h4 id="I-下载opencv"><a href="#I-下载opencv" class="headerlink" title="I 下载opencv"></a>I 下载opencv</h4><p>下载地址：<a href="https://opencv.org/">opencv</a></p>
<p>在releases中下载Windows版本</p>
<p>注意安装路径</p>
<img src="/2021/11/17/vs2019%E9%85%8D%E7%BD%AEopencv-c-Windows/k1.png" style="zoom: 49%;">

<h4 id="II-配置环境变量"><a href="#II-配置环境变量" class="headerlink" title="II 配置环境变量"></a>II 配置环境变量</h4><p>此电脑–&gt;属性–&gt;高级系统设置–&gt;环境变量</p>
<p>在系统变量中选择Path，编辑</p>
<img src="/2021/11/17/vs2019%E9%85%8D%E7%BD%AEopencv-c-Windows/k2.png" style="zoom:50%;">

<p>添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#opencv文件中bin的路径</span></span><br><span class="line"><span class="comment">#例如</span></span><br><span class="line">C:\Leon\opencv\build\x64\vc15\bin</span><br></pre></td></tr></table></figure>

<h4 id="III-vs2019相关配置"><a href="#III-vs2019相关配置" class="headerlink" title="III vs2019相关配置"></a>III vs2019相关配置</h4><h5 id="1-包含目录与库目录"><a href="#1-包含目录与库目录" class="headerlink" title="1.包含目录与库目录"></a>1.包含目录与库目录</h5><p>新建一个C++空项目，Debug切换到 X64；</p>
<p>点击view–&gt;other windows-&gt;property manager</p>
<img src="/2021/11/17/vs2019%E9%85%8D%E7%BD%AEopencv-c-Windows/k3.png" style="zoom: 60%;">

<p>右击Debug|x64，选择properties</p>
<p><img src="/2021/11/17/vs2019%E9%85%8D%E7%BD%AEopencv-c-Windows/vs2019%E9%85%8D%E7%BD%AEopencv-c-Windows%5Ck4.png"></p>
<p>在VC++ Directories中编辑Include Directories与Library Directories</p>
<img src="/2021/11/17/vs2019%E9%85%8D%E7%BD%AEopencv-c-Windows/k5.png" style="zoom:80%;">

<p>Include Directories 中添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意修改路径</span></span><br><span class="line">E:\leon\opencv\build\include</span><br><span class="line">E:\leon\opencv\build\include\opencv2</span><br></pre></td></tr></table></figure>

<p>Library Directories 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:\leon\opencv\build\x64\vc14\lib</span><br></pre></td></tr></table></figure>

<h5 id="2-链接器"><a href="#2-链接器" class="headerlink" title="2.链接器"></a>2.链接器</h5><p>Linker–&gt;Input–&gt;Additional Dependencies添加</p>
<p>opencv_world453d.lib</p>
<p><strong>注意453是版本号，其他版本请修改</strong></p>
<img src="/2021/11/17/vs2019%E9%85%8D%E7%BD%AEopencv-c-Windows/k6.png" style="zoom:80%;">

<h4 id="IV-测试"><a href="#IV-测试" class="headerlink" title="IV 测试"></a>IV 测试</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(<span class="string">&quot;C:\\opencvtest\\test01.png&quot;</span>);    <span class="comment">//引号内选一张自己计算机内的图片的路径</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;success&quot;</span>, img);    <span class="comment">//打开一个窗口，显示图片</span></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);    <span class="comment">//在键盘敲入字符前程序处于等待状态</span></span><br><span class="line">	<span class="built_in">destroyAllWindows</span>();    <span class="comment">//关闭所有窗口</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若成功显示图片则配置完成</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2021/12/28/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="一、遍历"><a href="#一、遍历" class="headerlink" title="一、遍历"></a>一、遍历</h1><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,v);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,v);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,v);</span><br><span class="line">    	v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,v);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,v);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,v);</span><br><span class="line">    	v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h4><h5 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* cur = st.<span class="built_in">top</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">auto</span> cur=root;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()||cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                cur=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* cur=st.<span class="built_in">top</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先遍历-层序遍历"><a href="#广度优先遍历-层序遍历" class="headerlink" title="广度优先遍历(层序遍历)"></a>广度优先遍历(层序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n=que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t=que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) que.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) que.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">                vec.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="二、常见操作"><a href="#二、常见操作" class="headerlink" title="二、常见操作"></a>二、常见操作</h1><h3 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">invert</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(TreeNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">        std::<span class="built_in">swap</span>(cur-&gt;left,cur-&gt;right);</span><br><span class="line">        <span class="built_in">rev</span>(cur-&gt;left);</span><br><span class="line">        <span class="built_in">rev</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="判断是否对称"><a href="#判断是否对称" class="headerlink" title="判断是否对称"></a>判断是否对称</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t1 &amp;&amp; t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//注意要比较的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(t1-&gt;left, t2-&gt;right) &amp;&amp; <span class="built_in">compare</span>(t1-&gt;right,t2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="求深度"><a href="#求深度" class="headerlink" title="求深度"></a>求深度</h3><h5 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t1=<span class="built_in">getDepth</span>(node-&gt;left);  <span class="comment">//左子树高度</span></span><br><span class="line">        <span class="keyword">int</span> t2=<span class="built_in">getDepth</span>(node-&gt;right); <span class="comment">//右子树高度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(t1,t2)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMin</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftdepth=<span class="built_in">getMin</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightdepth=<span class="built_in">getMin</span>(node-&gt;right);</span><br><span class="line">        <span class="comment">//处理左右节点为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left&amp;&amp;node-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+rightdepth;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left&amp;&amp;!node-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+leftdepth;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">min</span>(leftdepth,rightdepth);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断平衡"><a href="#判断平衡" class="headerlink" title="判断平衡"></a>判断平衡</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isb</span>(root)==<span class="number">-1</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isBalanced</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="built_in">isBalanced</span>(node-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> right=<span class="built_in">isBalanced</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(right==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//返回-1表示终止</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(left,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h3><h5 id="前序与中序遍历构造"><a href="#前序与中序遍历构造" class="headerlink" title="前序与中序遍历构造"></a>前序与中序遍历构造</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tra</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>(), inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">tra</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> preBegin, <span class="keyword">int</span> preEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> inBegin, <span class="keyword">int</span> inEnd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preBegin == preEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//切割区间左闭右开</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当前节点数值为前序数组首项</span></span><br><span class="line">        <span class="keyword">int</span> val = preorder[preBegin];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(preEnd-preBegin == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = inBegin; i &lt; inEnd; ++i)</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//切分中序</span></span><br><span class="line">        <span class="keyword">int</span> inBeginleft = inBegin, inEndleft = i;</span><br><span class="line">        <span class="keyword">int</span> inBeginright = <span class="number">1</span> + i, inEndright = inEnd;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//切分前序</span></span><br><span class="line">        <span class="keyword">int</span> preBeginleft = <span class="number">1</span> + preBegin;</span><br><span class="line">        <span class="keyword">int</span> preEndleft = preBeginleft + inEndleft - inBeginleft;</span><br><span class="line">        <span class="keyword">int</span> preBeginright = preEndleft;</span><br><span class="line">        <span class="keyword">int</span> preEndright = preEnd;</span><br><span class="line">        </span><br><span class="line">        root-&gt;left = <span class="built_in">tra</span>(preorder, preBeginleft, preEndleft, inorder,</span><br><span class="line">                       inBeginleft, inEndleft);</span><br><span class="line">        root&gt;right = <span class="built_in">tra</span>(preorder, preBeginright, preEndright,</span><br><span class="line">                       inorder, inBeginright, inEndright);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="中序与后序遍历构造"><a href="#中序与后序遍历构造" class="headerlink" title="中序与后序遍历构造"></a>中序与后序遍历构造</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), </span><br><span class="line">        postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> inBegin, <span class="keyword">int</span> inEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> poBegin, <span class="keyword">int</span> poEnd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(poBegin == poEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//切割区间左闭右开</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当前节点数值为后序数组末项</span></span><br><span class="line">        <span class="keyword">int</span> val = postorder[poEnd - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(poEnd - poBegin == <span class="number">1</span>) <span class="keyword">return</span> root;<span class="comment">//仅有一项，为叶，返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target;<span class="comment">//搜索左右子树分界点</span></span><br><span class="line">        <span class="keyword">for</span>(target = inBegin; target &lt; inEnd; ++target)</span><br><span class="line">            <span class="keyword">if</span>(inorder[target] == val) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//切分中序</span></span><br><span class="line">        <span class="keyword">int</span> leftinBegin = inBegin, leftinEnd = target;</span><br><span class="line">        <span class="keyword">int</span> righrinBegin = target + <span class="number">1</span>, rightinEnd = inEnd;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//切分后续</span></span><br><span class="line">        <span class="keyword">int</span> leftpoBegin = poBegin, leftpoEnd = poBegin + target - inBegin;</span><br><span class="line">        <span class="keyword">int</span> rightpoBegin = leftpoEnd, rightpoEnd = poEnd - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(inorder, leftinBegin, leftinEnd,</span><br><span class="line">        postorder,leftpoBegin, leftpoEnd);</span><br><span class="line"></span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(inorder, righrinBegin, rightinEnd,</span><br><span class="line">        postorder, rightpoBegin, rightpoEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、二叉搜索树"><a href="#三、二叉搜索树" class="headerlink" title="三、二叉搜索树"></a>三、二叉搜索树</h1><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断是否为二叉搜索树"><a href="#判断是否为二叉搜索树" class="headerlink" title="判断是否为二叉搜索树"></a>判断是否为二叉搜索树</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历二叉搜索树，节点数值递增</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">        <span class="keyword">bool</span> b1 = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">bool</span> b2 = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> b1 &amp;&amp; b2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="求众数的集合"><a href="#求众数的集合" class="headerlink" title="求众数的集合"></a>求众数的集合</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">int</span> maxcount;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        maxcount = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">        pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">ser</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ser</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">ser</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre) <span class="keyword">if</span>(pre-&gt;val == node-&gt;val)</span><br><span class="line">                    ++count;</span><br><span class="line">                <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxcount)</span><br><span class="line">        &#123;</span><br><span class="line">            maxcount = count;</span><br><span class="line">            result.<span class="built_in">clear</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count == maxcount)</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        pre = node;</span><br><span class="line">        <span class="built_in">ser</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制炸弹 phase_6</title>
    <url>/2021/12/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B9-phase-6/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048b71 &lt;phase_6&gt;:</span><br><span class="line"> 8048b71:	55                   	push   %ebp</span><br><span class="line"> 8048b72:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048b74:	56                   	push   %esi</span><br><span class="line"> 8048b75:	53                   	push   %ebx</span><br><span class="line"> 8048b76:	83 ec 48             	sub    $0x48,%esp</span><br><span class="line"> 8048b79:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax</span><br><span class="line"> 8048b7f:	89 45 f4             	mov    %eax,-0xc(%ebp)</span><br><span class="line"> 8048b82:	31 c0                	xor    %eax,%eax</span><br><span class="line"> 8048b84:	8d 45 c4             	lea    -0x3c(%ebp),%eax</span><br><span class="line"> 8048b87:	50                   	push   %eax</span><br><span class="line"> 8048b88:	ff 75 08             	pushl  0x8(%ebp)</span><br><span class="line"> 8048b8b:	e8 5b 03 00 00       	call   8048eeb &lt;read_six_numbers&gt;</span><br><span class="line"> 8048b90:	83 c4 10             	add    $0x10,%esp</span><br><span class="line"> 8048b93:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line"> </span><br><span class="line"> #read_six_numbers函数读取六个整数</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 																				#for(i=0;i&lt;6;++i) #处理a[i]</span><br><span class="line"> 																				</span><br><span class="line"> 8048b98:	8b 44 b5 c4          	mov    -0x3c(%ebp,%esi,4),%eax			</span><br><span class="line"> 8048b9c:	83 e8 01             	sub    $0x1,%eax</span><br><span class="line"> 8048b9f:	83 f8 05             	cmp    $0x5,%eax #每个数都小于六</span><br><span class="line"> 8048ba2:	76 05                	jbe    8048ba9 &lt;phase_6+0x38&gt;</span><br><span class="line"> 8048ba4:	e8 1a 03 00 00       	call   8048ec3 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> 8048ba9:	83 c6 01             	add    $0x1,%esi  #外循环</span><br><span class="line"> 8048bac:	83 fe 06             	cmp    $0x6,%esi </span><br><span class="line"> 8048baf:	74 1b                	je     8048bcc &lt;phase_6+0x5b&gt;</span><br><span class="line"> 8048bb1:	89 f3                	mov    %esi,%ebx</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 8048bb3:	8b 44 9d c4          	mov    -0x3c(%ebp,%ebx,4),%eax</span><br><span class="line"> 8048bb7:	39 44 b5 c0          	cmp    %eax,-0x40(%ebp,%esi,4) #六个数无重复 </span><br><span class="line"> 8048bbb:	75 05                	jne    8048bc2 &lt;phase_6+0x51&gt;</span><br><span class="line"> 8048bbd:	e8 01 03 00 00       	call   8048ec3 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> 8048bc2:	83 c3 01             	add    $0x1,%ebx</span><br><span class="line"> 8048bc5:	83 fb 05             	cmp    $0x5,%ebx</span><br><span class="line"> 8048bc8:	7e e9                	jle    8048bb3 &lt;phase_6+0x42&gt; #内循环 </span><br><span class="line"> 8048bca:	eb cc                	jmp    8048b98 &lt;phase_6+0x27&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #循环结束</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> 8048bcc:	8d 45 c4             	lea    -0x3c(%ebp),%eax</span><br><span class="line"> 8048bcf:	8d 5d dc             	lea    -0x24(%ebp),%ebx  #取址</span><br><span class="line"> 8048bd2:	b9 07 00 00 00       	mov    $0x7,%ecx</span><br><span class="line"> </span><br><span class="line"> 8048bd7:	89 ca                	mov    %ecx,%edx</span><br><span class="line"> 8048bd9:	2b 10                	sub    (%eax),%edx</span><br><span class="line"> 8048bdb:	89 10                	mov    %edx,(%eax)</span><br><span class="line"> 8048bdd:	83 c0 04             	add    $0x4,%eax</span><br><span class="line"> 8048be0:	39 c3                	cmp    %eax,%ebx</span><br><span class="line"> 8048be2:	75 f3                	jne    8048bd7 &lt;phase_6+0x66&gt; #循环实现a[i]=7-a[i];</span><br><span class="line"> </span><br><span class="line"> 8048be4:	bb 00 00 00 00       	mov    $0x0,%ebx  #ebx为偏移量</span><br><span class="line"> 8048be9:	eb 16                	jmp    8048c01 &lt;phase_6+0x90&gt;</span><br><span class="line"> </span><br><span class="line"> 8048beb:	8b 52 08             	mov    0x8(%edx),%edx</span><br><span class="line"> 8048bee:	83 c0 01             	add    $0x1,%eax</span><br><span class="line"> 8048bf1:	39 c8                	cmp    %ecx,%eax</span><br><span class="line"> 8048bf3:	75 f6                	jne    8048beb &lt;phase_6+0x7a&gt;</span><br><span class="line"> 8048bf5:	89 54 b5 dc          	mov    %edx,-0x24(%ebp,%esi,4)  </span><br><span class="line"> 8048bf9:	83 c3 01             	add    $0x1,%ebx</span><br><span class="line"> 8048bfc:	83 fb 06             	cmp    $0x6,%ebx</span><br><span class="line"> 8048bff:	74 17                	je     8048c18 &lt;phase_6+0xa7&gt;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 8048c01:	89 de                	mov    %ebx,%esi</span><br><span class="line"> 8048c03:	8b 4c 9d c4          	mov    -0x3c(%ebp,%ebx,4),%ecx</span><br><span class="line"> 8048c07:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line"> 8048c0c:	ba 34 b1 04 08       	mov    $0x804b134,%edx </span><br><span class="line"> </span><br><span class="line"> #ecx=a[i]使用edx= *(edx+ 8) 构造value指针，edx初始地址为0x804b134</span><br><span class="line"> </span><br><span class="line"> #依次加8，获取下一结点地址，输出各个数：109、302、870、275、602、109</span><br><span class="line"> </span><br><span class="line"> 8048c11:	83 f9 01             	cmp    $0x1,%ecx #循环 </span><br><span class="line"> 8048c14:	7f d5                	jg     8048beb &lt;phase_6+0x7a&gt;</span><br><span class="line"> 8048c16:	eb dd                	jmp    8048bf5 &lt;phase_6+0x84&gt;</span><br><span class="line"> </span><br><span class="line"> #构造链表，比较相邻元素</span><br><span class="line"> </span><br><span class="line"> 8048c18:	8b 5d dc             	mov    -0x24(%ebp),%ebx</span><br><span class="line"> 8048c1b:	8d 45 dc             	lea    -0x24(%ebp),%eax</span><br><span class="line"> 8048c1e:	8d 75 f0             	lea    -0x10(%ebp),%esi</span><br><span class="line"> 8048c21:	89 d9                	mov    %ebx,%ecx</span><br><span class="line"> </span><br><span class="line"> 8048c23:	8b 50 04             	mov    0x4(%eax),%edx</span><br><span class="line"> 8048c26:	89 51 08             	mov    %edx,0x8(%ecx)</span><br><span class="line"> 8048c29:	83 c0 04             	add    $0x4,%eax </span><br><span class="line"> 8048c2c:	89 d1                	mov    %edx,%ecx</span><br><span class="line"> 8048c2e:	39 c6                	cmp    %eax,%esi</span><br><span class="line"> 8048c30:	75 f1                	jne    8048c23 &lt;phase_6+0xb2&gt; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 8048c32:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)</span><br><span class="line"> 8048c39:	be 05 00 00 00       	mov    $0x5,%esi #esi为循环标</span><br><span class="line"> </span><br><span class="line"> 8048c3e:	8b 43 08             	mov    0x8(%ebx),%eax   </span><br><span class="line"> # %ebx = *(value[i] + 8) = next + i。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 8048c41:	8b 00                	mov    (%eax),%eax</span><br><span class="line"> 8048c43:	39 03                	cmp    %eax,(%ebx)        #比较eax与ebx内容</span><br><span class="line"> 8048c45:	7d 05                	jge    8048c4c &lt;phase_6+0xdb&gt; #单调不增</span><br><span class="line"> 8048c47:	e8 77 02 00 00       	call   8048ec3 &lt;explode_bomb&gt;</span><br><span class="line"> 8048c4c:	8b 5b 08             	mov    0x8(%ebx),%ebx</span><br><span class="line"> 8048c4f:	83 ee 01             	sub    $0x1,%esi #循环比较五次</span><br><span class="line"> 8048c52:	75 ea                	jne    8048c3e &lt;phase_6+0xcd&gt;</span><br><span class="line"> </span><br><span class="line"> 8048c54:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 8048c57:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax</span><br><span class="line"> 8048c5e:	74 05                	je     8048c65 &lt;phase_6+0xf4&gt;</span><br><span class="line"> 8048c60:	e8 7b f9 ff ff       	call   80485e0 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line"> 8048c65:	8d 65 f8             	lea    -0x8(%ebp),%esp</span><br><span class="line"> 8048c68:	5b                   	pop    %ebx</span><br><span class="line"> 8048c69:	5e                   	pop    %esi</span><br><span class="line"> 8048c6a:	5d                   	pop    %ebp</span><br><span class="line"> 8048c6b:	c3                   	ret    </span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>回文日期</title>
    <url>/2021/12/02/%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<p>今天 20211202</p>
<p>回文日期标准：</p>
<p>​    年份取四位，月、日取二位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个特殊的字符串类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> SpString <span class="title">s_reverse</span><span class="params">(SpString t)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout,SpString k);</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">Stoi</span><span class="params">(SpString t)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(string t);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(string t);</span><br><span class="line">    <span class="function">SpString <span class="title">subs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">SpString <span class="title">SpString::subs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    SpString t;</span><br><span class="line">    t=s.<span class="built_in">substr</span>(index,len);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stoi</span><span class="params">(SpString t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stoi</span>(t.s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> SpString::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            s[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SpString <span class="title">s_reverse</span><span class="params">(SpString t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(t.s.<span class="built_in">begin</span>(),t.s.<span class="built_in">end</span>());</span><br><span class="line">    SpString k;</span><br><span class="line">    k=t.s;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> SpString::<span class="keyword">operator</span>=(string t)</span><br><span class="line">&#123;</span><br><span class="line">    s=t;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout,SpString k)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;k.s;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> SpString::<span class="keyword">operator</span>&lt;=(string t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s&lt;=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isr</span><span class="params">(<span class="keyword">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>||(year%<span class="number">100</span>!=<span class="number">0</span>&amp;&amp;year%<span class="number">4</span>==<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> month[]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>,j;</span><br><span class="line">    SpString s;</span><br><span class="line">    <span class="keyword">for</span>(s=<span class="string">&quot;0001&quot;</span>,j=<span class="number">1</span>;s&lt;=<span class="string">&quot;2021&quot;</span>;++s,++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">isr</span>(j);</span><br><span class="line">        month[<span class="number">2</span>]=(b==<span class="number">1</span>?<span class="number">29</span>:<span class="number">28</span>);</span><br><span class="line">        SpString tmp=<span class="built_in">s_reverse</span>(s);</span><br><span class="line">        <span class="keyword">int</span> t1=<span class="built_in">Stoi</span>(tmp.<span class="built_in">subs</span>(<span class="number">0</span>,<span class="number">2</span>)),t2=<span class="built_in">Stoi</span>(tmp.<span class="built_in">subs</span>(<span class="number">2</span>,<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span>(t1&lt;=<span class="number">12</span>&amp;&amp;t1&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t2&lt;=month[t1]&amp;&amp;t2&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;++cnt&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 01011010</span><br><span class="line">2 01100110</span><br><span class="line">3 01111110</span><br><span class="line">4 01200210</span><br><span class="line">5 01211210</span><br><span class="line">6 01300310</span><br><span class="line">7 01400410</span><br><span class="line">8 01500510</span><br><span class="line">9 01600610</span><br><span class="line">10 01700710</span><br><span class="line">11 01800810</span><br><span class="line">12 01900910</span><br><span class="line">13 02011020</span><br><span class="line">14 02100120</span><br><span class="line">15 02111120</span><br><span class="line">16 02200220</span><br><span class="line">17 02211220</span><br><span class="line">18 02300320</span><br><span class="line">19 02400420</span><br><span class="line">20 02500520</span><br><span class="line">21 02600620</span><br><span class="line">22 02700720</span><br><span class="line">23 02800820</span><br><span class="line">24 02900920</span><br><span class="line">25 03011030</span><br><span class="line">26 03100130</span><br><span class="line">27 03111130</span><br><span class="line">28 03211230</span><br><span class="line">29 03300330</span><br><span class="line">30 03400430</span><br><span class="line">31 03500530</span><br><span class="line">32 03600630</span><br><span class="line">33 03700730</span><br><span class="line">34 03800830</span><br><span class="line">35 03900930</span><br><span class="line">36 10011001</span><br><span class="line">37 10100101</span><br><span class="line">38 10111101</span><br><span class="line">39 10200201</span><br><span class="line">40 10211201</span><br><span class="line">41 10300301</span><br><span class="line">42 10400401</span><br><span class="line">43 10500501</span><br><span class="line">44 10600601</span><br><span class="line">45 10700701</span><br><span class="line">46 10800801</span><br><span class="line">47 10900901</span><br><span class="line">48 11011011</span><br><span class="line">49 11100111</span><br><span class="line">50 11111111</span><br><span class="line">51 11200211</span><br><span class="line">52 11211211</span><br><span class="line">53 11300311</span><br><span class="line">54 11400411</span><br><span class="line">55 11500511</span><br><span class="line">56 11600611</span><br><span class="line">57 11700711</span><br><span class="line">58 11800811</span><br><span class="line">59 11900911</span><br><span class="line">60 12011021</span><br><span class="line">61 12100121</span><br><span class="line">62 12111121</span><br><span class="line">63 12200221</span><br><span class="line">64 12211221</span><br><span class="line">65 12300321</span><br><span class="line">66 12400421</span><br><span class="line">67 12500521</span><br><span class="line">68 12600621</span><br><span class="line">69 12700721</span><br><span class="line">70 12800821</span><br><span class="line">71 12900921</span><br><span class="line">72 13011031</span><br><span class="line">73 13100131</span><br><span class="line">74 13211231</span><br><span class="line">75 13300331</span><br><span class="line">76 13500531</span><br><span class="line">77 13700731</span><br><span class="line">78 13800831</span><br><span class="line">79 20011002</span><br><span class="line">80 20100102</span><br><span class="line">81 20111102</span><br><span class="line">82 20200202</span><br><span class="line">83 20211202</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2021/12/15/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>均按非降序排序</p>
<h4 id="一、计数排序"><a href="#一、计数排序" class="headerlink" title="一、计数排序"></a>一、计数排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmax</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;max) max=arr[i];</span><br><span class="line">    <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">findmax</span>(arr,n);</span><br><span class="line">    <span class="keyword">int</span> *bkt=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="built_in">memset</span>(bkt,<span class="number">0</span>,len*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        ++bkt[arr[i]];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) </span><br><span class="line">        <span class="keyword">while</span>(bkt[i]--)</span><br><span class="line">            arr[k++]=i;</span><br><span class="line">    <span class="keyword">delete</span> []bkt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[i])</span><br><span class="line">                std::<span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="三、冒泡排序"><a href="#三、冒泡排序" class="headerlink" title="三、冒泡排序"></a>三、冒泡排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;++j)</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">                std::<span class="built_in">swap</span>(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四、插入排序"><a href="#四、插入排序" class="headerlink" title="四、插入排序"></a>四、插入排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur=arr[i],j;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;cur) arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        arr[j+<span class="number">1</span>]=cur;</span><br><span class="line">    &#125;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a>五、希尔排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> gap,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur=arr[i],j;</span><br><span class="line">    <span class="keyword">for</span>(j=i-gap;j&gt;=<span class="number">0</span>&amp;&amp;arr[j]&gt;cur;j-=gap)</span><br><span class="line">        arr[j+gap]=arr[j];</span><br><span class="line">    arr[j+gap]=cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap;</span><br><span class="line">    <span class="keyword">for</span>(gap=n/<span class="number">2</span>;gap;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;n;++i)</span><br><span class="line">            <span class="built_in">insert</span>(arr,gap,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="六、快速排序"><a href="#六、快速排序" class="headerlink" title="六、快速排序"></a>六、快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">int</span> ar[];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=ar[left];</span><br><span class="line">    i=left; j=right;</span><br><span class="line">    <span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ar[j]&gt;=temp&amp;&amp;i&lt;j) --j;</span><br><span class="line">        <span class="keyword">while</span>(ar[i]&lt;=temp&amp;&amp;i&lt;j) ++i;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) std::<span class="built_in">swap</span>(ar[i],ar[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ar[left]=ar[i];</span><br><span class="line">    ar[i]=temp;</span><br><span class="line">    <span class="built_in">quick_sort</span>(left,i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quick_sort</span>(i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>* arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=left,j=right;</span><br><span class="line">    <span class="keyword">int</span> temp=arr[left];</span><br><span class="line">    <span class="keyword">while</span>(i!=j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[j]&gt;=temp&amp;&amp;i&lt;j) --j;</span><br><span class="line">        <span class="keyword">while</span>(arr[i]&lt;=temp&amp;&amp;i&lt;j) ++i;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) std::<span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left]=arr[i];</span><br><span class="line">    arr[i]=temp;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=n<span class="number">-1</span>;</span><br><span class="line">    std::stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(left);</span><br><span class="line">    st.<span class="built_in">push</span>(right);</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        right=st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        left=st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> index=<span class="built_in">division</span>(left,right,arr);</span><br><span class="line">        <span class="keyword">if</span>(index-left&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(left);</span><br><span class="line">            st.<span class="built_in">push</span>(index<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right-index&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(index+<span class="number">1</span>);</span><br><span class="line">            st.<span class="built_in">push</span>(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="七、桶排序"><a href="#七、桶排序" class="headerlink" title="七、桶排序"></a>七、桶排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min=arr[<span class="number">0</span>],max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;max) max=arr[i];</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;min) min=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt;* bucket=<span class="keyword">new</span> std::vector&lt;<span class="keyword">int</span>&gt;[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=(arr[i]-min)*(n<span class="number">-1</span>)/(max-min);</span><br><span class="line">        bucket[tmp].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i].<span class="built_in">size</span>()&gt;<span class="number">1</span>) <span class="built_in">sort</span>(bucket[i].<span class="built_in">begin</span>(),bucket[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t2:bucket[i])</span><br><span class="line">            arr[k++]=t2;</span><br><span class="line">    <span class="keyword">delete</span> []bucket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="八、基数排序"><a href="#八、基数排序" class="headerlink" title="八、基数排序"></a>八、基数排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tenx</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        ret*=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;max) max=arr[i];</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(max/=<span class="number">10</span>) ++num;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt;* bucket=<span class="keyword">new</span> std::vector&lt;<span class="keyword">int</span>&gt;[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=arr[j]/<span class="built_in">tenx</span>(i)%<span class="number">10</span>;</span><br><span class="line">            bucket[tmp].<span class="built_in">push_back</span>(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t:bucket[i]) arr[k++]=t;</span><br><span class="line">            bucket[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []bucket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="九、归并排序"><a href="#九、归并排序" class="headerlink" title="九、归并排序"></a>九、归并排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span>* tmp,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left1=left,right1=mid;</span><br><span class="line">    <span class="keyword">int</span> left2=mid+<span class="number">1</span>,right2=right;</span><br><span class="line">    <span class="keyword">int</span> k=left;</span><br><span class="line">    <span class="keyword">while</span>(left1&lt;=right1 &amp;&amp; left2&lt;=right2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left1]&lt;arr[left2]) tmp[k++]=arr[left1++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++]=arr[left2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left1&lt;=right1) tmp[k++]=arr[left1++];</span><br><span class="line">    <span class="keyword">while</span>(left2&lt;=right2) tmp[k++]=arr[left2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;++i) arr[i]=tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* tmp=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(len&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+len&lt;=n;i+=(len&lt;&lt;<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left=i;</span><br><span class="line">            <span class="keyword">int</span> mid=i+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> right=i+(len&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;n<span class="number">-1</span>) right=n<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">merge</span>(arr,tmp,left,mid,right);</span><br><span class="line">        &#125;</span><br><span class="line">        len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">const</span> <span class="keyword">int</span> n,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> *temp=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left1=left,right1=mid;</span><br><span class="line">    <span class="keyword">int</span> left2=mid+<span class="number">1</span>,right2=right;</span><br><span class="line">    <span class="built_in">merge_sort</span>(arr,n,left1,right1);</span><br><span class="line">    <span class="built_in">merge_sort</span>(arr,n,left2,right2);</span><br><span class="line">    <span class="keyword">int</span> k=left;</span><br><span class="line">    <span class="keyword">while</span>(left1&lt;=right1&amp;&amp;left2&lt;=right2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left1]&lt;=arr[left2]) temp[k++]=arr[left1++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++]=arr[left2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left1&lt;=right1) temp[k++]=arr[left1++];</span><br><span class="line">    <span class="keyword">while</span>(left2&lt;=right2) temp[k++]=arr[left2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;++i) arr[i]=temp[i];</span><br><span class="line">    <span class="keyword">delete</span> []temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="十、堆排序"><a href="#十、堆排序" class="headerlink" title="十、堆排序"></a>十、堆排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftdown</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span>((i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;arr[(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>]) t=((i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">else</span> t=i;</span><br><span class="line">        <span class="keyword">if</span>((i&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>&lt;n)</span><br><span class="line">            <span class="keyword">if</span>(arr[(i&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>]&lt;arr[t]) </span><br><span class="line">                t=(i&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(t!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[i],arr[t]);</span><br><span class="line">            i=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_heap</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=((n<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>);i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="built_in">siftdown</span>(arr,n,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select_min</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt=n;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t=arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">0</span>]=arr[cnt<span class="number">-1</span>];</span><br><span class="line">    --cnt;</span><br><span class="line">    <span class="built_in">siftdown</span>(arr,cnt,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) a[i]=arr[i];</span><br><span class="line">    <span class="built_in">creat_heap</span>(a,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) arr[i]=<span class="built_in">select_min</span>(a,n);</span><br><span class="line">    <span class="keyword">delete</span> []a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftdown</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span>((i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;arr[(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>]) t=((i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">else</span> t=i;</span><br><span class="line">        <span class="keyword">if</span>((i&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>&lt;n)</span><br><span class="line">            <span class="keyword">if</span>(arr[(i&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>]&gt;arr[t]) </span><br><span class="line">                t=(i&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(t!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[i],arr[t]);</span><br><span class="line">            i=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_heap</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=((n<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>);i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="built_in">siftdown</span>(arr,n,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">creat_heap</span>(arr,n);</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[<span class="number">0</span>],arr[n<span class="number">-1</span>]);</span><br><span class="line">        --n;</span><br><span class="line">        <span class="built_in">siftdown</span>(arr,n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/11/17/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h5 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h5><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Leetcode链接</a></p>
<p>通过一个快指针和一个慢指针在一个for循环中完成删除</p>
<p>时间复杂度O(n)</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa,slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(fa=<span class="number">1</span>;fa&lt;nums.<span class="built_in">size</span>();++fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fa]&gt;nums[slow])</span><br><span class="line">                nums[++slow]=nums[fa];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="比较含退格的字符串"><a href="#比较含退格的字符串" class="headerlink" title="比较含退格的字符串"></a>比较含退格的字符串</h5><p><a href="https://leetcode.com/problems/backspace-string-compare/">Leetcode链接</a></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>,j=t.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ns=<span class="number">0</span>,nt=<span class="number">0</span>;<span class="comment">//记录s与t中#的数量</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)<span class="comment">//从后向前消除s的#</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;#&#x27;</span>)   ns++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ns&gt;<span class="number">0</span>)    ns--;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)<span class="comment">//从后向前消除t的#</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[j]==<span class="string">&#x27;#&#x27;</span>)   nt++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nt&gt;<span class="number">0</span>)    nt--;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>)    <span class="keyword">break</span>;<span class="comment">//当某个字符串遍历完时退出</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]!=t[j])  <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//在某处字符不同可判定不相等</span></span><br><span class="line">        i--;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">-1</span>&amp;&amp;j==<span class="number">-1</span>)<span class="comment">//字符，长度均相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//去除多余空格后，先将字符串全反转，再逐一反转单词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,len=s.<span class="built_in">length</span>(),slow;</span><br><span class="line">        <span class="keyword">while</span>(s[i]==<span class="string">&#x27; &#x27;</span>)<span class="comment">//去除前置空格</span></span><br><span class="line">            ++i;</span><br><span class="line">        s[<span class="number">0</span>]=s[i++];</span><br><span class="line">        <span class="keyword">for</span>(slow=<span class="number">1</span>;i&lt;len;++i)<span class="comment">//快慢指针，删除多余空格</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[i<span class="number">-1</span>]&amp;&amp;s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            s[slow++]=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理最后有空格的情况</span></span><br><span class="line">        <span class="keyword">if</span>(slow<span class="number">-1</span>&gt;<span class="number">0</span>&amp;&amp;s[slow<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            s.<span class="built_in">resize</span>(slow<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s.<span class="built_in">resize</span>(slow);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> k=s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c=s.<span class="built_in">begin</span>();c!=s.<span class="built_in">end</span>();++c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*c==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(k,c);</span><br><span class="line">                k=c+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(k,s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h5 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h5><p><a href="https://leetcode.com/problems/minimum-size-subarray-sum/">leetcode209</a></p>
<p>暴力解法 用两个for循环，时间复杂度O(n^2);</p>
<p>滑动窗口法：</p>
<p>​        用两个指针，形成一个范围，根据范围内数组元素的和进行指针的移动。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.<span class="built_in">size</span>())<span class="comment">// i在前</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">while</span>(target&lt;=sum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k=i-j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(k&lt;min) min=k;</span><br><span class="line">                sum-=nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=<span class="number">1</span>&lt;&lt;<span class="number">30</span>) <span class="keyword">return</span> min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a>水果成篮</h5><p><a href="https://leetcode.com/problems/fruit-into-baskets/">leetcode904</a></p>
<p>使用 unordered_map，在超过三个数时移动指针</p>
<p>如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">0</span>;fast&lt;fruits.<span class="built_in">size</span>();++fast)</span><br><span class="line">        &#123;</span><br><span class="line">            m[fruits[fast]]++;</span><br><span class="line">            <span class="keyword">while</span>(m.<span class="built_in">size</span>()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                m[fruits[slow]]--;</span><br><span class="line">                <span class="keyword">if</span>(m[fruits[slow]]==<span class="number">0</span>)</span><br><span class="line">                    m.<span class="built_in">erase</span>(fruits[slow]);</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(ret&lt;fast-slow+<span class="number">1</span>)</span><br><span class="line">                ret=fast-slow+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>栈与队列</title>
    <url>/2021/11/23/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="栈与队列相互实现"><a href="#栈与队列相互实现" class="headerlink" title="栈与队列相互实现"></a>栈与队列相互实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈实现队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() : <span class="built_in">s_in</span>() , <span class="built_in">s_out</span>() </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s_in.<span class="built_in">push</span>(x);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s_out.<span class="built_in">empty</span>()) </span><br><span class="line">            <span class="keyword">while</span>(!s_in.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                s_out.<span class="built_in">push</span>(s_in.<span class="built_in">top</span>());</span><br><span class="line">                s_in.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp=s_out.<span class="built_in">top</span>();</span><br><span class="line">        s_out.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        s_out.<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s_in.<span class="built_in">empty</span>() &amp;&amp; s_out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s_in;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s_out;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列实现栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() : <span class="built_in">q</span>() </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t--)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最大值总是在队首</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonotonicQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MonotonicQueue</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> q.<span class="built_in">front</span>();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line">MonotonicQueue::<span class="built_in">MonotonicQueue</span>() : <span class="built_in">q</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MonotonicQueue::push</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">back</span>()&lt;val) q.<span class="built_in">pop_back</span>();</span><br><span class="line">    q.<span class="built_in">push_back</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MonotonicQueue::pop</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!q.<span class="built_in">empty</span>() &amp;&amp; val==q.<span class="built_in">front</span>()) q.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        MonotonicQueue sq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) sq.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(sq.<span class="built_in">getmax</span>());</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::size_type j=k;j&lt;nums.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            sq.<span class="built_in">pop</span>(nums[j-k]);</span><br><span class="line">            sq.<span class="built_in">push</span>(nums[j]);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(sq.<span class="built_in">getmax</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2021/12/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>有n件物品与一个承重w的背包，第i件物品的重量是weight[i]，价值是value[i]，每件物品只能用一次，求装入物品价值总和的最大值。</p>
<h4 id="二维数组dp"><a href="#二维数组dp" class="headerlink" title="二维数组dp"></a>二维数组dp</h4><h5 id="dp数组含义"><a href="#dp数组含义" class="headerlink" title="dp数组含义"></a>dp数组含义</h5><p>dp[i] [j] 表示从物品0-i中取物品，放入承重为j的背包中的最大价值。</p>
<h5 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j]<span class="comment">/*不装入物品i*/</span>, dp[i - <span class="number">1</span>][j - weight[i]] + value[i]<span class="comment">/*装入i*/</span>);</span><br></pre></td></tr></table></figure>

<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(w + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//放入第一个物品</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = weight[<span class="number">0</span>]; j &lt; w; ++j)</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)    <span class="comment">//遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j)   <span class="comment">//遍历背包承重</span></span><br><span class="line">        <span class="keyword">if</span>(j - weight[i] &gt;= <span class="number">0</span>)</span><br><span class="line">        	dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<h4 id="滚动数组dp"><a href="#滚动数组dp" class="headerlink" title="滚动数组dp"></a>滚动数组dp</h4><h5 id="dp数组含义-1"><a href="#dp数组含义-1" class="headerlink" title="dp数组含义"></a>dp数组含义</h5><p>dp[i]表示承重为i的背包可装入的最大价值</p>
<h5 id="递推公式-1"><a href="#递推公式-1" class="headerlink" title="递推公式"></a>递推公式</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = w; j &gt;= weight; --j)  <span class="comment">//倒序遍历，防止同一物品多次放入背包</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><h6 id="目标和Target-Sum"><a href="#目标和Target-Sum" class="headerlink" title="目标和Target Sum"></a>目标和<a href="https://leetcode-cn.com/problems/target-sum/">Target Sum</a></h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k : nums)</span><br><span class="line">            sum += k;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> wt = sum + target;</span><br><span class="line">        <span class="keyword">if</span>(wt % <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        wt /= <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(wt + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = wt; j &gt;= nums[i]; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[wt];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="一和零Ones-and-Zeroes"><a href="#一和零Ones-and-Zeroes" class="headerlink" title="一和零Ones and Zeroes"></a>一和零<a href="https://leetcode-cn.com/problems/ones-and-zeroes/">Ones and Zeroes</a></h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">oneNums</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">zeroNums</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : strs[i])</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) ++zeroNums;</span><br><span class="line">                <span class="keyword">else</span> ++oneNums;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= zeroNums; --j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = n; k &gt;= oneNums; --k)</span><br><span class="line">                    dp[j][k] = std::<span class="built_in">max</span>(dp[j][k],</span><br><span class="line">                    dp[j - zeroNums][k - oneNums] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>物品可以重复使用。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i]; j &lt;= weight; ++j)  <span class="comment">//正序遍历</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><h6 id="零钱兑换II-Coin-Change-2"><a href="#零钱兑换II-Coin-Change-2" class="headerlink" title="零钱兑换II[Coin Change 2]"></a>零钱兑换II<a href="https://leetcode-cn.com/problems/coin-change-2/">[Coin Change 2]</a></h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求组合数，先遍历物品</span></span><br><span class="line"><span class="comment">//求排列数，先遍历背包容量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); ++i) <span class="comment">//求组合数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = coins[i]; j &lt;= amount; ++j)</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="组合总和-ⅣCombination-IV"><a href="#组合总和-ⅣCombination-IV" class="headerlink" title="组合总和 ⅣCombination IV"></a>组合总和 Ⅳ<a href="https://leetcode-cn.com/problems/combination-sum-iv/">Combination IV</a></h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本题求排列数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= target; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                <span class="keyword">if</span>(j - nums[i] &gt;= <span class="number">0</span> &amp;&amp; </span><br><span class="line">                dp[j] &lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]];</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h2><h6 id="出现个数-Distinct-Subsequences"><a href="#出现个数-Distinct-Subsequences" class="headerlink" title="出现个数[Distinct Subsequences]"></a>出现个数<a href="https://leetcode-cn.com/problems/distinct-subsequences/comments/">[Distinct Subsequences]</a></h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">uint64_t</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">uint64_t</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><h6 id="两个字符串的删除操作-Delete-Operation-for-Two-Strings"><a href="#两个字符串的删除操作-Delete-Operation-for-Two-Strings" class="headerlink" title="两个字符串的删除操作[Delete Operation for Two Strings]"></a>两个字符串的删除操作<a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">[Delete Operation for Two Strings]</a></h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">length</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(word2.<span class="built_in">length</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">length</span>(); ++i)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">length</span>(); ++j)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(string::size_type i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">decltype</span>(i) j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">length</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = std::<span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, </span><br><span class="line">                    dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>&#125;); </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/11/17/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h3><p>移除链表元素</p>
<p><a href="https://leetcode.com/problems/remove-linked-list-elements/">leetcode203https://leetcode.com/problems/r…</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      ListNode *next;</span><br><span class="line">      <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">      <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">      <span class="built_in">ListNode</span>(<span class="keyword">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>若直接使用原始链表，删除头节点的操作与其他节点不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 删除头结点 </span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val) &#123; <span class="comment">// 注意使用while</span></span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除非头结点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>使用虚拟头节点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ListNode* dummyHead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">dummyHead-&gt;next=head</span><br><span class="line"><span class="comment">//使原先的头节点失去特殊地位</span></span><br><span class="line"><span class="comment">//最后记得要返回dummyHead-&gt;next.</span></span><br></pre></td></tr></table></figure>

<p>代码为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyHead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyHead-&gt;next=head;</span><br><span class="line">        <span class="keyword">auto</span> vi=dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(vi-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vi-&gt;next-&gt;val==val)&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp=vi-&gt;next;</span><br><span class="line">                vi-&gt;next=tmp-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                vi=vi-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h4 id="反转链表I"><a href="#反转链表I" class="headerlink" title="反转链表I"></a>反转链表I</h4><p><a href="https://leetcode.com/problems/reverse-linked-list/">https://leetcodereverse-linked-list/</a></p>
<h5 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h5><p>pre与cur指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre=<span class="literal">nullptr</span>,*cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* temp=cur-&gt;next;<span class="comment">//保存cur-&gt;next，因为它会被更改</span></span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;<span class="comment">//新的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rev</span>(head,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rev</span><span class="params">(ListNode* cur,ListNode* pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)	<span class="keyword">return</span> pre;</span><br><span class="line">        <span class="keyword">auto</span> temp=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rev</span>(temp,cur);<span class="comment">//相当于pre=cur;cur=temp;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="反转链表II"><a href="#反转链表II" class="headerlink" title="反转链表II"></a>反转链表II</h4><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/">leetcode.com/problems…</a></p>
<h5 id="截断"><a href="#截断" class="headerlink" title="截断"></a>截断</h5><p>截断待反转的区域，将它反转再重新插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	ListNode *cur=head,*pre=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right==left)  <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummyHead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyHead-&gt;next=head;</span><br><span class="line">        ListNode *pre=dummyHead,*rtnode,*ltnode,*nex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;left<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ltnode=pre-&gt;next;</span><br><span class="line">        rtnode=ltnode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;right-left;++i)&#123;</span><br><span class="line">            rtnode=rtnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        nex=rtnode-&gt;next;</span><br><span class="line">        <span class="comment">/*至此已获得四个需要的指针: pre, ltnode, rtnode, nex*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//截断</span></span><br><span class="line">		pre-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        rtnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        <span class="built_in">rev</span>(ltnode);</span><br><span class="line">        <span class="comment">//插回</span></span><br><span class="line">        </span><br><span class="line">        pre-&gt;next=rtnode;</span><br><span class="line">        ltnode-&gt;next=nex;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummyNode=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyNode-&gt;next=head;</span><br><span class="line">        ListNode *cur,*Next,*pre=dummyNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;left<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=pre-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;right-left;++i)&#123;</span><br><span class="line">            Next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=Next-&gt;next;</span><br><span class="line">            Next-&gt;next=pre-&gt;next;</span><br><span class="line">            pre-&gt;next=Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="环"><a href="#环" class="headerlink" title="环"></a>环</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">leetcode环形链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast=head,*slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                ListNode *ind1=head,*ind2=fast;</span><br><span class="line">                <span class="keyword">while</span>(ind1!=ind2)&#123;</span><br><span class="line">                    ind1=ind1-&gt;next;</span><br><span class="line">                    ind2=ind2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ind1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单向链表排序"><a href="#单向链表排序" class="headerlink" title="单向链表排序"></a>单向链表排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead=<span class="keyword">new</span> ListNode;</span><br><span class="line">        dummyHead-&gt;next=head;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* cur=dummyHead-&gt;next;</span><br><span class="line">            ListNode* tail=dummyHead;</span><br><span class="line">            <span class="keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> left=cur;</span><br><span class="line">                <span class="keyword">auto</span> right=<span class="built_in">cut</span>(left,i);</span><br><span class="line">                cur=<span class="built_in">cut</span>(right,i);</span><br><span class="line">                tail-&gt;next=<span class="built_in">merge</span>(left,right);</span><br><span class="line">                <span class="keyword">while</span>(tail-&gt;next) tail=tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> ret=dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">cut</span><span class="params">(ListNode* head,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">while</span>(--n &amp;&amp; cur)</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* ret=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* left,ListNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* dummyHead=<span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode* p=dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(left &amp;&amp; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val&lt;right-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=left;</span><br><span class="line">                p=left;</span><br><span class="line">                left=left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=right;</span><br><span class="line">                p=right;</span><br><span class="line">                right=right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next= left ? left : right;</span><br><span class="line">        <span class="keyword">auto</span> ret=dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="计算PI"><a href="#计算PI" class="headerlink" title="计算PI"></a>计算PI</h3><p>利用反三角函数幂级展开式进行计算</p>
<img src="/2021/11/17/%E9%93%BE%E8%A1%A8/Vito\source\_posts\高精度计算PI\k.png" style="zoom: 100%;">

<p>经计算，取n = 2000可以保证前550位的精度</p>
<h4 id="模拟大数运算"><a href="#模拟大数运算" class="headerlink" title="模拟大数运算"></a>模拟大数运算</h4><h5 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h5><p>从尾至头做乘法，处理进位。若有溢出，可在链表头部添加节点，也可以不加。</p>
<p>1、添加节点后，增加的是整数位，小数点后位数不变，由于乘发结束后要除以一个更大的数</p>
<p>（即2*i-1 &gt; i - 1），整数位均变为0，执行加法时，从两链表尾部开始遍历，到短链表头处终止即可，前面整数部分的零无需参与加法运算。</p>
<p>2、不添加节点，整数位会大于10，同理，做除法后整数位必定为零，因此只需处理第2位及以后的进位。</p>
<h5 id="加法与除法"><a href="#加法与除法" class="headerlink" title="加法与除法"></a>加法与除法</h5><p>分别倒序顺序遍历。</p>
<p>除法运算还有构建链表的作用，在计算过程中向后补位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    LinkedNode* next;</span><br><span class="line">    LinkedNode* pre;</span><br><span class="line">    <span class="comment">//设置尾节点，便于倒序遍历</span></span><br><span class="line">    LinkedNode* tail;</span><br><span class="line">    <span class="built_in">LinkedNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">tail</span>(<span class="keyword">this</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">LinkedNode</span>(<span class="keyword">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>), </span><br><span class="line">    <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">tail</span>(<span class="keyword">this</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Lptr = LinkedNode*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高精度计算类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caculation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//重载+、*、/</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+(Caculation&amp; cal);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*(<span class="keyword">int</span> val);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/(<span class="keyword">int</span> val);</span><br><span class="line">    <span class="comment">//输出前n位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="comment">//初始化函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//初始化存放结果的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initRet</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">Caculation</span>() &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Caculation</span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="built_in">initRet</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取p</span></span><br><span class="line">    <span class="function">Lptr <span class="title">getP</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> p;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//此为头节点</span></span><br><span class="line">    Lptr p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求前550位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function">Caculation <span class="title">result</span><span class="params">(<span class="number">1</span>)</span>, head</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        head * (i - <span class="number">1</span>);</span><br><span class="line">        head / ((i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">        result + head;</span><br><span class="line">    &#125;</span><br><span class="line">    result * <span class="number">2</span>;</span><br><span class="line">    result.<span class="built_in">print</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caculation::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> q = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">1</span>);</span><br><span class="line">    q-&gt;pre = p;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    p-&gt;tail = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caculation::initRet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> L = p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);</span><br><span class="line">        cur-&gt;pre = L;</span><br><span class="line">        L-&gt;next = cur;</span><br><span class="line">        L = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next-&gt;val = <span class="number">1</span>;</span><br><span class="line">    p-&gt;tail = L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caculation::print</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cur = p-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.&quot;</span>, cur-&gt;val);</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cur-&gt;val);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Caculation::<span class="keyword">operator</span>+(Caculation&amp; cal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> p2 = cal.<span class="built_in">getP</span>();</span><br><span class="line">    Lptr t1 = <span class="keyword">this</span>-&gt;p-&gt;tail, t2 = p2-&gt;tail;</span><br><span class="line">    <span class="keyword">while</span>(t1 != <span class="keyword">this</span>-&gt;p &amp;&amp; t2 != p2)</span><br><span class="line">    &#123;</span><br><span class="line">        t1-&gt;val += t2-&gt;val;</span><br><span class="line">        t1-&gt;pre-&gt;val += t1-&gt;val / <span class="number">10</span>;</span><br><span class="line">        t1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">        t1 = t1-&gt;pre;</span><br><span class="line">        t2 = t2-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Caculation::<span class="keyword">operator</span>/(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//进位</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">carry</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//位数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> cur = p-&gt;next;</span><br><span class="line">    <span class="comment">//记录前一位</span></span><br><span class="line">    Lptr pre;</span><br><span class="line">    <span class="comment">//模拟除法</span></span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;val += carry * <span class="number">10</span>;</span><br><span class="line">        carry = cur-&gt;val % val;</span><br><span class="line">        cur-&gt;val /= val;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        ++len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回退</span></span><br><span class="line">    cur = pre;</span><br><span class="line">    <span class="keyword">while</span>(carry &amp;&amp; len &lt;= Max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);</span><br><span class="line">        newNode-&gt;val = carry * <span class="number">10</span>;</span><br><span class="line">        newNode-&gt;pre = cur;</span><br><span class="line">        carry = newNode-&gt;val % val;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        newNode-&gt;val /= val;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        cur = newNode;</span><br><span class="line">        ++len;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;tail = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Caculation::<span class="keyword">operator</span>*(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    Lptr cur = p-&gt;tail;</span><br><span class="line">    <span class="comment">//先做乘法</span></span><br><span class="line">    <span class="keyword">while</span>(cur != p)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;val *= val;</span><br><span class="line">        cur = cur-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再处理进位</span></span><br><span class="line">    cur = p-&gt;tail;</span><br><span class="line">    <span class="keyword">while</span>(cur != p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;pre-&gt;val += cur-&gt;val / <span class="number">10</span>;</span><br><span class="line">        cur-&gt;val %= <span class="number">10</span>;</span><br><span class="line">        cur = cur-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可添加节点</span></span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;val &gt;= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);</span><br><span class="line">        newNode-&gt;val = cur-&gt;val / <span class="number">10</span>;</span><br><span class="line">        cur-&gt;val %= <span class="number">10</span>;</span><br><span class="line">        newNode-&gt;pre = p;</span><br><span class="line">        newNode-&gt;next = cur;</span><br><span class="line">        p-&gt;next = newNode;</span><br><span class="line">        cur-&gt;pre = newNode;</span><br><span class="line">        cur = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
